
                .include "submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

                .weak
model_b=false
model_bplus=false
model_master=false
master_first_sideways_ram_bank=4
master_num_sideways_ram_banks=4
                .endweak

                .if (model_b?1:0)+(model_bplus?1:0)+(model_master?1:0)!=1
                .error "must specify single model type"
                .endif

master_test_sideways_ram=master_num_sideways_ram_banks>0

;-------------------------------------------------------------------------

*=$c000

                .if model_b||model_bplus

                ; For B+, memory test needs to go first, as the shadow
                ; RAM loads/stores need to be in the MOS VDU driver
                ; area at $c000-$dfff.
                .dsection memory_test
                .dsection user_interface
                .dsection bits_test
                .dsection data
                ;.dsection memory_test_patterns
                .dsection memory_test_error

                .elif model_master

                .dsection user_interface
                .dsection data
                .dsection memory_test_error

                ; For Master, memory test wants to go last, as it has
                ; to be out of the way of HAZEL.
                .if *<$e000-(memory_test.page_in_hazel-memory_test)
*=$e000-(memory_test.page_in_hazel-memory_test)
                .endif
                .dsection memory_test
                .dsection bits_test
                
                .endif
                
                
                .cerror *>$fc00,format('code overflow: *=$%04x',*)
*=$fc00
                .fill 768,0     ; stop I/O region appearing as a gap
                                ; in the assembler output

*=$ff00
                
                .dsection entry_points
                .dsection memory_test_patterns
                
*=$fffa
                .dsection vectors

;-------------------------------------------------------------------------

; Page numbers:

; Range         B         B+          Master
; -----         -         --          ------
;  $00 -  $7F   Main RAM
;  $80 -  $90   -         ANDY        ANDY
;  $A0 -  $AF   -         ANDY        HAZEL
;  $B0 -  $FF   -         Shadow RAM  Shadow RAM
; $180 - $1BF   -         -           Sideways RAM
;
; The sideways RAM bank being tested is not part of the page number.
; It's read from ROMSEL (hence lack of equivalent B+128
; functionality).
                
test_page_address: .function page
                .if page>=0&&page<$80
                ; main RAM
_addr=page*256
                .elsif model_bplus&&page>=$80&&page<$b0
_addr=page*256
                .elsif (model_bplus||model_master)&&page>=$b0&&page<$100
                .if model_bplus
                ; access to this region is only possible from
                ; instructions fetched from a particular address
                ; range.
                .cerror !(*>=$c000&&*<$e000)
                .endif
_addr=(page-($b0-$30))*256
                .elsif model_master&&page>=$80&&page<$90
_addr=page*256
                .elsif model_master&&page>=$90&&page<$b0
                ; code accessing this region should be placed elsewhere!
                .cerror *>=$c000&&*<$e000
_addr=$c000+(page-$90)*256
                .elsif model_master&&page>=$180&&page<$1c0
_addr=(page&$ff)*256
                .else
                .error format("invalid page number: $%02x (%d)",page,page)
                .endif
                .endfunction _addr
                
;-------------------------------------------------------------------------

; Preserves Y/C
set_mode: .macro table,palette,ula
                lda #\ula
                sta video_ula_control

                ldx #size(\table)-1
-
                stx $fe00
                lda \table,x
                sta $fe01
                dex
                bpl -

                .if \palette>=0
                ldx #15
-
                lda \palette,x
                sta video_ula_palette
                dex
                bpl -
                .endif
                .endmacro

;-------------------------------------------------------------------------

; Preserves Y/C
copy_message: .macro addr,text
                ldx #0
-
                inx
                lda \text-1,x
                sta \addr-1,x
                bpl -
                .endmacro

;-------------------------------------------------------------------------

; Preserves A/Y/C
handle_key: .macro key,routine
                ldx #\key
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl not_pressed
wait_for_up_loop:
                bit system_via.ora_no_handshake
                bmi wait_for_up_loop
                jmp \routine
not_pressed:
                .endmacro

;-------------------------------------------------------------------------

draw_msn_glyph: .macro mode,xc,yc
                and #$f0        ; (n>>4)*16
                lsr a           ; (n>>4)*8
                .draw_glyph \mode,\xc,\yc
                .endmacro

draw_lsn_glyph: .macro mode,xc,yc
                and #$0f
                asl a
                asl a
                asl a
                .draw_glyph \mode,\xc,\yc
                .endmacro

draw_glyph: .macro mode,xc,yc
                tax

                .if \mode==7

                ldy #7
loop:
                .for _y=0,_y<8,_y+=1
                lda glyphs_rows[_y],x
                bne +

                ; Better to use $20 than $00, as if bits other than
                ; bit 5 are stuck ; high then you won't get any
                ; control chars that could muck things up. (If bit 5
                ; is stuck low, best hope other bits aren't stuck
                ; high! Or try a bitmap mode...)
                lda #$20
+
                sta $7c00+((\yc)*8+_y)*40+(\xc)*8,y
                .endfor
                inx
                dey
                bpl loop

                .elif \mode==4

                ldy #63
loop:
loop2:
                .for _y=0,_y<8,_y+=1
                lda glyphs_rows[_y],x
                sta $5800+((\yc)*8+_y)*320+(\xc)*64,y
                .endfor
                dey
                tya
                and #7
                cmp #7
                bne loop2
                inx
                cpy #$ff
                bne loop
                
                .else
                .error
                .endif
                
                .endmacro

;-------------------------------------------------------------------------

error_screen: .macro mode
                
                ; Problem address
addr_x:=0
                .if model_master
                lda romsel
                and #$0f
                .draw_lsn_glyph \mode,addr_x,0
addr_x:=addr_x+1
                .endif
                tsx
                txa
                .draw_msn_glyph \mode,addr_x,0
addr_x:=addr_x+1
                tsx
                txa
                .draw_lsn_glyph \mode,addr_x,0
addr_x:=addr_x+1
                lda system_via.t1l_h
                .draw_msn_glyph \mode,addr_x,0
addr_x:=addr_x+1
                lda system_via.t1l_h
                .draw_lsn_glyph \mode,addr_x,0
addr_x:=addr_x+1

                ; Problem bits
                lda system_via.t1l_l
                .draw_msn_glyph \mode,0,1
                lda system_via.t1l_l
                .draw_lsn_glyph \mode,1,1

                jmp hang
                
                .endmacro
                
;-------------------------------------------------------------------------

; Preserves X/Y/C
activate_shadow: .macro
                .if model_bplus
                lda #$80
                sta acccon
                .elif model_master
                lda #acccon.x
                tsb acccon
                .else
                .cerror
                .endif
                .endmacro

deactivate_shadow: .macro
                .if model_bplus
; Preserves X/Y/C
                lda #$00
                sta acccon
                .elif model_master
                lda #acccon.x
                trb acccon
                .else
                .cerror
                .endif
                .endmacro
                
;-------------------------------------------------------------------------

                .section user_interface
reset:

                ; disable ANDY on B+
                lda #0
                sta $fe30       ; disable ANDY (if B+ or later)

                ; disable shadow RAM on B+
                sta $fe34       ; select main RAM (if B+ or later)
                
                ; check if initialisation was (probably) run on a
                ; previous boot
                ldy #0          ; not previously initialised
                lda system_via.ddra
                cmp #%01111111
                bne +
                lda system_via.ddrb
                cmp #%00001111
                bne +
                lda system_via.acr
                bne +

                ; Looks like this isn't a power-on boot
                dey
+
                ; Port B writes to addressable latch
                lda #%00001111
                sta system_via.ddrb

                ; Disable port A input latching
                lda #0
                sta system_via.acr

                ; Disable sound write, speech read, speech write,
                ; keyboard write.
                ldx #8+0
                stx system_via.orb ; bit 0 - sound write
                inx
                stx system_via.orb ; bit 1 - speech read
                inx
                stx system_via.orb ; bit 2 - speech write
                inx
                stx system_via.orb ; bit 3 - keyboard write

                ; Silence sound
                lda #%10011111  ; tone 3 max attenuation
silence_sound_loop:
                ldx #$ff
                stx system_via.ddra
                sta system_via.ora_no_handshake
                ldx #0+0
                stx system_via.orb
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                ldx #8+0
                stx system_via.orb
                clc
                adc #%00100000  ; next channel
                bcc silence_sound_loop

                ; Port A keyboard access
                lda #%01111111
                sta system_via.ddra

                lda #8+0        ; disable sound write
                sta system_via.orb
                lda #8+1        ; disable speech read
                sta system_via.orb
                lda #8+2        ; disable speech write
                sta system_via.orb
                lda #0+3        ; enable keyboard write
                sta system_via.orb

                ; set 20 KB CRTC wraparound
                lda #8+5
                sta system_via.orb
                lda #0+4
                sta system_via.orb
                
                lda #0+6        ; caps lock LED off
                sta system_via.orb
                lda #8+7        ; shift lock LED off
                sta system_via.orb

                lda #0
                .rept 10
                sta 0
                .endrept

                ; Only initialise mode on a power-on reset
                cpy #0
                bne +
                .set_mode crtc_teletext,-1,$4a
+
                
main_menu:
                ldy #0          ; LED state counter
main_menu_loop:
                ; .handle_key key_caps_lock,toggle_caps_lock_led
                .handle_key key_m,memory_test
                .handle_key key_b,bits_test
                .handle_key key_0,set_mode_0
                .handle_key key_4,set_mode_4
                .handle_key key_7,set_mode_7
                .handle_key key_e,teletext_engineering_test
                .handle_key key_x,error

                ; delay ~3,000 cycles
                ldx #0
delay_loop:
                .rept 10
                nop
                .endrept
                inx
                bne delay_loop

                iny
                tya
                lsr a           ; 07654321
                lsr a           ; 00765432
                lsr a           ; 00076543
                lsr a           ; 00007654
                and #8
                ora #6          ; caps lock LED
                sta system_via.orb
                eor #8|(6^7)    ; opposite state for shift lock LED
                sta system_via.orb
                
                jmp main_menu_loop

set_mode_0:
                .set_mode crtc_20KB,palette_mono,$9c
                jmp main_menu_loop

set_mode_4:
                .set_mode crtc_10KB,palette_mono,$88
                jmp main_menu_loop

teletext_engineering_test:
                ldx #0
-
                .for _i=0,_i<4,_i+=1
                lda engtest+_i*256,x
                sta $7c00+_i*256,x
                .endfor
                inx
                bne -
                
                .cerror *!=set_mode_7 ; fall through

set_mode_7:
                .set_mode crtc_teletext,-1,$4a
                jmp main_menu_loop
                .endsection

;-------------------------------------------------------------------------

                .section bits_test
bits_test: .proc
                .if model_bplus||model_master
                lda #$80
                sta romsel
                .endif

                .if model_bplus
                lda #$00             ; shadow off
                sta system_via.t1l_l ; acccon value
                .elif model_master
                .cerror *>=$c000&&*<$e000
                lda #acccon.y   ; HAZEL on, display main RAM
                tsb acccon
                .endif

fill_00:
                lda #$00
fill:
                sta system_via.t1l_h
                ldx #0
                
                .if model_bplus||model_master
                .deactivate_shadow
                .endif
                
fill_loop:
                lda system_via.t1l_h
                
                ; fill main RAM
                .for _i=0,_i<$80,_i+=1
                sta test_page_address(_i),x
                .endfor

                .if model_bplus||model_master

                ; fill ANDY/HAZEL
                .for _i=$80,_i<$b0,_i+=1
                sta test_page_address(_i),x
                .endfor

                ; fill shadow RAM
                .activate_shadow
                lda system_via.t1l_h
                .for _i=$b0,_i<$100,_i+=1
                sta test_page_address(_i),x
                .endfor
                .deactivate_shadow

                .endif

                inx
                bne fill_loop

test_loop:
                .if model_bplus
                lda system_via.t1l_l
                sta acccon
                .endif
                
                handle_key key_space,toggle_address
                lda system_via.t1l_h
                handle_key key_0,toggle_0
                handle_key key_1,toggle_1
                handle_key key_2,toggle_2
                handle_key key_3,toggle_3
                handle_key key_4,toggle_4
                handle_key key_5,toggle_5
                handle_key key_6,toggle_6
                handle_key key_7,toggle_7
                handle_key key_8,fill_00
                handle_key key_9,fill_ff
                handle_key key_f,fill
                .if model_bplus||model_master
                handle_key key_m,display_main
                handle_key key_s,display_shadow
                .endif
                jmp test_loop

fill_ff:
                lda #$ff
                jmp fill

toggle_0:
                eor #$01
                jmp fill

toggle_1:
                eor #$02
                jmp fill

toggle_2:
                eor #$04
                jmp fill

toggle_3:
                eor #$08
                jmp fill

toggle_4:
                eor #$10
                jmp fill

toggle_5:
                eor #$20
                jmp fill

toggle_6:
                eor #$40
                jmp fill

toggle_7:
                eor #$80
                jmp fill

                .if model_bplus||model_master
display_main:
                .if model_bplus
                lda #0
                sta system_via.t1l_l
                .else
                lda #acccon.d
                trb acccon
                .endif
                jmp test_loop

display_shadow:
                .if model_bplus
                lda #$80
                sta system_via.t1l_l
                .else
                lda #acccon.d
                tsb acccon
                .endif
                jmp test_loop

                .endif

toggle_address:
                lda #12
                sta $fe00
                lda $fe01
                cmp #$20
                bcs cycle_done  ; taken if mode 7 - don't adjust
                clc
                adc #$20>>3     ; +8 KB
                cmp #$10        ; past end of RAM?
                bcc got_addr    ; taken if ok
                lda #$00        ; reset address
got_addr:
                sta $fe01       ; update address
cycle_done:
                
                and #%00001100  ; extract 8 KB region index
                
                ; Reflect address in LEDs. Only bits 0-3 of ORB are
                ; outputs so bits 4-7 in the value written can be
                ; anything.
                asl a           ; %000xy000
                eor #%00011000  ; since 1=LED off, 0=LED on
                ora #7          ; do shift lock LED
                sta system_via.orb
                lsr a
                and #8          ; mask off just LED state
                ora #6          ; do caps lock LED
                sta system_via.orb
                
                jmp test_loop
               .endproc
               .endsection
                
;-------------------------------------------------------------------------

                .section memory_test
                
test_fill_iteration: .segment page
                sta test_page_address(\page),y
                .endsegment

test_check_iteration: .segment page
                lda test_page_address(\page),y ; fetch memory byte
                eor patterns,x                 ; get differences from pattern
                and system_via.t1l_h           ; mask out ignore bits
                beq +

                ldx #(\page)&$ff
                jmp error
+
                .endsegment
                
memory_test: .proc
                ; the T1 latch can act as a handy 16 bits of (slightly
                ; slow) RAM. IRQs are disabled so it doesn't matter if
                ; the timer times out more often.
                lda #$ff
                sta system_via.t1l_h ; keep bits
                
                ldx #key_shift
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl test

read_msn:
                ldx #8+6        ; caps lock off
                stx system_via.orb
                ldx #8+7        ; shift lock off
                stx system_via.orb

                ldx #15
msn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_msn_key
wait_for_msn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_msn_key_up
                txa
                asl a
                asl a
                asl a
                asl a
                sta system_via.t1l_h
                jmp read_lsn
next_msn_key:
                dex
                bpl msn_loop
                jmp read_msn

read_lsn:
                ldx #0+6        ; caps lock on
                stx system_via.orb

                ldx #15
lsn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_lsn_key
wait_for_lsn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_lsn_key_up
                txa
                ora system_via.t1l_h
                eor #$ff        ; convert ignore bits to keep bits
                sta system_via.t1l_h
                jmp test
next_lsn_key:
                dex
                bpl lsn_loop
                jmp read_lsn
                
test:
                ; There's no keyboard input from this point, so the
                ; system VIA ACR is available for use.

                ldx #0          ; per-byte increment
                stx system_via.acr

                ; 
                
                ldx #0+6        ; caps lock on
                stx system_via.orb
                ldx #0+7        ; shift lock on
                stx system_via.orb

                .if model_master
page_in_hazel:
                ; page in HAZEL
                .cerror *>=$c000&&*<$e000
                lda #acccon.y
                tsb acccon
                .endif

test_loop:
                
                ldx #0
                txs             ; loop cunter
                
                ldy #0          ; Y = page offset
fill_loop:
                .if model_bplus||model_master
                ; enable ANDY and select bank 0
                lda #$80
                sta romsel
                .endif

                lda patterns,x

                ; fill main RAM                
                .for _i=0,_i<$80,_i+=1
                .test_fill_iteration _i
                .endfor

                .if model_bplus||model_master
                
                ; fill ANDY
                .for _i=$80,_i<$b0,_i+=1
                .test_fill_iteration _i
                .endfor

                ; fill shadow
                .activate_shadow
                lda patterns,x
                .for _i=$c0,_i<$100,_i+=1
                .test_fill_iteration _i
                .endfor
                .deactivate_shadow

                .endif

                .if model_master&&master_test_sideways_ram

                ; fill banks 4-7. Also disable ANDY
                lda #master_first_sideways_ram_bank
                sta romsel
rom_fill_loop:
                lda patterns,x
                .for _i=$180,_i<$1c0,_i+=1
                .test_fill_iteration _i
                .endfor

                inc romsel
                lda romsel
                cmp #master_first_sideways_ram_bank+master_num_sideways_ram_banks
                bne rom_fill_loop

                .endif

                clc
                txa
                adc system_via.acr
                and #size(patterns)-1
                tax
                
                iny
                bne fill_loop

                ; Delay ~165 ms - give memory time to decay, if
                ; refresh isn't working properly.
                ldy #0
                ldx #0
decay_loop:
                inx
                bne decay_loop
                iny
                bne decay_loop

                tsx
check_loop:
                .if model_bplus||model_master
                ; enable ANDY and select bank 0
                lda #$80
                sta romsel
                .endif
                
                .for _i=0,_i<$80,_i+=1
                .test_check_iteration _i
                .endfor

                .if model_bplus||model_master

                ; check ANDY
                .for _i=$80,_i<$b0,_i+=1
                .test_check_iteration _i
                .endfor

                ; check shadow
                .activate_shadow
                .for _i=$c0,_i<$100,_i+=1
                .test_check_iteration _i
                .endfor
                .deactivate_shadow

                .endif

                .if model_master&&master_test_sideways_ram

                ; check banks 4-7. Also disable ANDY
                lda #master_first_sideways_ram_bank
                sta romsel
rom_check_loop:
                .for _i=$180,_i<$1c0,_i+=1
                .test_check_iteration _i
                .endfor

                inc romsel
                lda romsel
                cmp #master_first_sideways_ram_bank+master_num_sideways_ram_banks
                bne rom_check_loop
                
                .endif

                clc
                txa
                adc system_via.acr
                and #size(patterns)-1
                tax

                iny
                bne check_loop

                pla             ; inc S
                tsx
                cpx #size(patterns)
                bne fill_loop

                inc system_via.acr
                
                jmp test_loop

                .endproc

                .endsection

;-------------------------------------------------------------------------

                .section memory_test_error
error_2: .proc
                ldx #8+6
                stx system_via.orb
                ldx #8+7
                stx system_via.orb

                lda #12
                sta $fe00
                lda $fe01
                and #$20
                bne mode_7_error_screen

mode_4_error_screen:
                .set_mode crtc_10KB,palette_mono,$88

                lda #12
                sta $fe00
                lda #$58>>3
                sta $fe01

                ldx #0
                lda #0
cls_mode_4_loop:
                .for _i=$58,_i<$80,_i+=1
                sta _i*256,x
                .endfor
                inx
                bne cls_mode_4_loop

                .error_screen 4
                jmp hang

mode_7_error_screen:
                .set_mode crtc_teletext,-1,$4a

                ldx #0
                lda #32
cls_mode_7_loop:
                sta $7c00,x
                sta $7d00,x
                sta $7e00,x
                sta $7f00,x
                inx
                bne cls_mode_7_loop

                .error_screen 7
                .endproc
                
hang:
                jmp hang

                .endsection

;-------------------------------------------------------------------------

                .section memory_test_patterns
pattern: .segment value
                .byte (\value)&$ff
                .byte (\value)&$ff^$ff
                .endsegment

patterns: .block
                ; .byte 1,2,4,8,16,32,64,128
                
                .pattern %00000000
                .pattern %01010101
                .pattern %00110011
                
                ; 5 bytes from random.org
                .pattern $a2
                .pattern $37
                .pattern $38
                .pattern $a5
                .pattern $57 
                
                .for _i=0,_i<8,_i+=1
                .pattern (1<<_i)
                .endfor
                .for _i=0,_i<8,_i+=1
                .pattern ($ff<<_i)
                .endfor
                .for _i=0,_i<8,_i+=1
                .pattern ($ff>>_i)
                .endfor
                
                .cerror ((*-patterns)&(*-patterns-1))!=0,format('not power of 2: %d',*-patterns)
                .endblock
                .endsection
                
;-------------------------------------------------------------------------

                .section data
msn_digit:
                .for _i=0,_i<256,_i+=1
                .byte format("%X",_i>>4)
                .endfor

lsn_digit:
                .for _i=0,_i<16,_i+=1
                .byte format("%X",_i&15)
                .endfor

;-------------------------------------------------------------------------

xdigit_keys:
                .byte key_0
                .byte key_1
                .byte key_2
                .byte key_3
                .byte key_4
                .byte key_5
                .byte key_6
                .byte key_7
                .byte key_8
                .byte key_9
                .byte key_a
                .byte key_b
                .byte key_c
                .byte key_d
                .byte key_e
                .byte key_f

;-------------------------------------------------------------------------

crtc_teletext: .block
                .byte  $3F  ; 0 Horizontal Total     =64
                .byte  $28  ; 1 Horizontal Displayed =40
                .byte  $33  ; 2 Horizontal Sync      =&33  Note: &31 is a better value
                .byte  $24  ; 3 HSync Width+VSync    =&24  VSync=2, HSync=4
                .byte  $1E  ; 4 Vertical Total       =30
                .byte  $02  ; 5 Vertical Adjust      =2
                .byte  $19  ; 6 Vertical Displayed   =25
                .byte  $1B  ; 7 VSync Position       =&1B
                .byte  $93  ; 8 Interlace+Cursor     =&93  Cursor=2, Display=1, Interlace=Sync+Video
                .byte  $12  ; 9 Scan Lines/Character =19
                .byte  $72 ;10 Cursor Start Line    =&72  Blink=On, Speed=1/32, Line=18
                .byte  $13  ;11 Cursor End Line      =19
                .byte $28,$00   ;12,13 start address
                .byte $28,$00   ; 14,15 cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_20KB: .block  ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
                .byte 0,0             ;R12,R13 - start address
                .byte $10,0;$30>>3,0             ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_10KB: .block ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total
                .byte $00                 ;R5 - Vertical Total Adjust
                .byte $20                 ;R6 - Vertical Displayed
                .byte $22                 ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
                .byte 0,0               ; R12,R13 - start address
                .byte $10,0               ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

palette_mono:
                .for _i=0,_i<16,_i+=1
                .byte _i<<4|(_i<8?7:0)
                .endfor

;-------------------------------------------------------------------------

engtest:
                .binary "engtest.dat"

;-------------------------------------------------------------------------

                .include "build/glyphs_data.generated.s65"

                .endsection
                
;-------------------------------------------------------------------------

                .section entry_points

error:
                ; X = page
                ; Y = page offset
                ; A = incorrect bits

                txs                  ; save page
                sta system_via.t1l_l ; incorrect bits
                sty system_via.t1l_h ; page offset

                .if model_bplus||model_master
                .deactivate_shadow
                .endif

                .if model_master
                lda #acccon.y
                trb acccon
                .endif

                jmp error_2

;-------------------------------------------------------------------------

reset_entry_point:
                sei
                cld
                
                lda #0
                .rept 5
                sta 0
                .endrept

                .if model_master
                ; Can't really avoid resetting this completely, as if
                ; TST is set then the value read is junk.
                stz acccon
                .endif
                
                jmp reset

;-------------------------------------------------------------------------

nmi_entry_point:
                rti

;-------------------------------------------------------------------------

irq_entry_point:
                rti

                .endsection

;-------------------------------------------------------------------------

                .section vectors
                .word nmi_entry_point
                .word reset_entry_point
                .word irq_entry_point
                .endsection

;-------------------------------------------------------------------------
