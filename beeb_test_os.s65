                .include "submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

; Better to use $20 than $00, as if bits other than bit 5 are stuck
; high then you won't get any control chars that could muck things up.
;
; If bit 5 is stuck low, best hope other bits aren't stuck high!
EMPTY_CHAR=$20
FILL_CHAR=$ff
                
;-------------------------------------------------------------------------

*=$c000
                .dsection code
                .cerror *>$fffa,'code overflow'
*=$fffa
                .dsection vectors

;-------------------------------------------------------------------------

; Preserves Y/C
set_mode: .macro table,palette,ula
                lda #\ula
                sta video_ula_control

                ldx #size(\table)-1
-
                stx $fe00
                lda \table,x
                sta $fe01
                dex
                bpl -

                .if \palette>=0
                ldx #15
-
                lda \palette,x
                sta video_ula_palette
                dex
                bpl -
                .endif
                .endmacro

; Preserves Y/C
copy_message: .macro addr,text
                ldx #0
-
                inx
                lda \text-1,x
                sta \addr-1,x
                bpl -
                .endmacro

; Preserves A/Y/C
handle_key: .macro key,routine
                ldx #\key
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl not_pressed
wait_for_up_loop:
                bit system_via.ora_no_handshake
                bmi wait_for_up_loop
                jmp \routine
not_pressed:
                .endmacro

; Preserves A/Y
cycle_crtc_address: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                cmp #$20
                bcs cycle_done  ; taken if mode 7 - don't adjust
                clc
                adc #$20>>3     ; +8 KB
                cmp #$10        ; past end of RAM?
                bcc got_addr    ; taken if ok
                lda #$00        ; reset address
got_addr:
                sta $fe01       ; update address
cycle_done:
                txa
                .endmacro

; Preserves A/Y
show_crtc_address_in_LEDs: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                and #%00001100  ; extract 8 KB region index
                
                ; Reflect address in LEDs. Only bits 0-3 of ORB are
                ; outputs so bits 4-7 in the value written can be
                ; anything.
                asl a           ; %000xy000
                eor #%00011000  ; since 1=LED off, 0=LED on
                ora #7          ; do shift lock LED
                sta system_via.orb
                lsr a
                and #8          ; mask off just LED state
                ora #6          ; do caps lock LED
                sta system_via.orb
                .endmacro

draw_msn_glyph: .macro addr
                and #$f0        ; (n>>4)*16
                lsr a           ; (n>>4)*8
                .draw_glyph \addr
                .endmacro

draw_lsn_glyph: .macro addr
                and #$0f
                asl a
                asl a
                asl a
                .draw_glyph \addr
                .endmacro

draw_glyph: .macro addr
                tax
                ldy #7
loop:
                .for _y=0,_y<8,_y+=1
                lda glyphs_rows[_y],x
                sta \addr+_y*40,y
                .endfor
                inx
                dey
                bpl loop
                .endmacro

mode_7_addr: .function _x,_y
                .endfunction $7c00+_y*40+_x
                
;-------------------------------------------------------------------------


                .section code
reset_entry_point:
                sei
                lda #0
                .rept 5
                sta 0
                .endrept

                ; disable ANDY on B+
                lda #0
                sta $fe30       ; disable ANDY (if B+ or later)

                ; disable shadow RAM on B+
                sta $fe34       ; select main RAM (if B+ or later)
                
                ; check if initialisation was (probably) run on a
                ; previous boot
                ldy #0          ; not previously initialised
                lda system_via.ddra
                cmp #%01111111
                bne +
                lda system_via.ddrb
                cmp #%00001111
                bne +
                lda system_via.acr
                bne +

                ; Looks like this isn't a power-on boot
                dey
+
                ; Port B writes to addressable latch
                lda #%00001111
                sta system_via.ddrb

                ; Disable port A input latching
                lda #0
                sta system_via.acr

                ; Disable sound write, speech read, speech write,
                ; keyboard write.
                ldx #8+0
                stx system_via.orb ; bit 0 - sound write
                inx
                stx system_via.orb ; bit 1 - speech read
                inx
                stx system_via.orb ; bit 2 - speech write
                inx
                stx system_via.orb ; bit 3 - keyboard write

                ; Silence sound
                lda #%10011111  ; tone 3 max attenuation
silence_sound_loop:
                ldx #$ff
                stx system_via.ddra
                sta system_via.ora_no_handshake
                ldx #0+0
                stx system_via.orb
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                ldx #8+0
                stx system_via.orb
                clc
                adc #%00100000  ; next channel
                bcc silence_sound_loop

                ; Port A keyboard access
                lda #%01111111
                sta system_via.ddra

                lda #8+0        ; disable sound write
                sta system_via.orb
                lda #8+1        ; disable speech read
                sta system_via.orb
                lda #8+2        ; disable speech write
                sta system_via.orb
                lda #0+3        ; enable keyboard write
                sta system_via.orb

                ; set 20 KB CRTC wraparound
                lda #8+5
                sta system_via.orb
                lda #0+4
                sta system_via.orb
                
                lda #0+6        ; caps lock LED off
                sta system_via.orb
                lda #8+7        ; shift lock LED off
                sta system_via.orb

                lda #0
                .rept 10
                sta 0
                .endrept

                ; Only initialise mode on a power-on reset
                cpy #0
                bne +
                .set_mode crtc_teletext,-1,$4a
+
                
main_menu:
                ldy #0          ; LED state counter
main_menu_loop:
                ; .handle_key key_caps_lock,toggle_caps_lock_led
                .handle_key key_m,memory_test
                .handle_key key_b,bits_test
                .handle_key key_0,set_mode_0
                .handle_key key_4,set_mode_4
                .handle_key key_7,set_mode_7
                .handle_key key_e,teletext_engineering_test
                .handle_key key_x,memory_test.error

                ; delay ~3,000 cycles
                ldx #0
delay_loop:
                .rept 10
                nop
                .endrept
                inx
                bne delay_loop

                iny
                tya
                lsr a           ; 07654321
                lsr a           ; 00765432
                lsr a           ; 00076543
                lsr a           ; 00007654
                and #8
                ora #6          ; caps lock LED
                sta system_via.orb
                eor #8|(6^7)    ; opposite state for shift lock LED
                sta system_via.orb
                
                jmp main_menu_loop

set_mode_0:
                .set_mode crtc_20KB,palette_mono,$9c
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

set_mode_4:
                .set_mode crtc_10KB,palette_mono,$88
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

teletext_engineering_test:
                ldx #0
-
                .for _i=0,_i<4,_i+=1
                lda engtest+_i*256,x
                sta $7c00+_i*256,x
                .endfor
                inx
                bne -
                
                .cerror *!=set_mode_7 ; fall through

set_mode_7:
                .set_mode crtc_teletext,-1,$4a
                jmp main_menu_loop

;-------------------------------------------------------------------------

bits_test: .proc

fill_00:
                lda #$00
fill:
                ldx #0
fill_loop:
                .for _i=0,_i<128,_i+=1
                sta _i*256,x
                .endfor
                inx
                bne fill_loop

test_loop:
                handle_key key_space,toggle_address
                handle_key key_0,toggle_0
                handle_key key_1,toggle_1
                handle_key key_2,toggle_2
                handle_key key_3,toggle_3
                handle_key key_4,toggle_4
                handle_key key_5,toggle_5
                handle_key key_6,toggle_6
                handle_key key_7,toggle_7
                handle_key key_8,fill_00
                handle_key key_9,fill_ff
                handle_key key_f,fill
                jmp test_loop

fill_ff:
                lda #$ff
                jmp fill

toggle_0:
                eor #$01
                jmp fill

toggle_1:
                eor #$02
                jmp fill

toggle_2:
                eor #$04
                jmp fill

toggle_3:
                eor #$08
                jmp fill

toggle_4:
                eor #$10
                jmp fill

toggle_5:
                eor #$20
                jmp fill

toggle_6:
                eor #$40
                jmp fill

toggle_7:
                eor #$80
                jmp fill

toggle_address:
                .cycle_crtc_address
                .show_crtc_address_in_LEDs
                jmp test_loop
               .endproc
                
;-------------------------------------------------------------------------

memory_test: .proc
                ; the T1 latch can act as a handy 16 bits of (slightly
                ; slow) RAM. IRQs are disabled so it doesn't matter if
                ; the timer times out more often.
                lda #0
                sta system_via.t1l_h
                
                ldx #key_shift
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl test

read_msn:
                ldx #8+6        ; caps lock off
                stx system_via.orb
                ldx #8+7        ; shift lock off
                stx system_via.orb

                ldx #15
msn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_msn_key
wait_for_msn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_msn_key_up
                txa
                asl a
                asl a
                asl a
                asl a
                sta system_via.t1l_h
                jmp read_lsn
next_msn_key:
                dex
                bpl msn_loop
                jmp read_msn

read_lsn:
                ldx #0+6        ; caps lock on
                stx system_via.orb

                ldx #15
lsn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_lsn_key
wait_for_lsn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_lsn_key_up
                txa
                ora system_via.t1l_h
                sta system_via.t1l_h
                jmp test
next_lsn_key:
                dex
                bpl lsn_loop
                jmp read_lsn
                
test:
                ldx #0+6        ; caps lock on
                stx system_via.orb
                ldx #0+7        ; shift lock on
                stx system_via.orb
                
                ldx #0          ; X = pattern index
                ldy #0          ; Y = page offset
fill_loop:
                lda patterns,x
                
                .for _i=0,_i<128,_i+=1
                sta _i*256,y
                .endfor

                iny
                bne fill_loop

check_loop:
                .for _i=0,_i<128,_i+=1
                lda patterns,x  ; fetch pattern byte
                and system_via.t1l_h ; keep ignore bits
                sta system_via.t1l_l ; temp...
                lda system_via.t1l_h ; fetch mask byte
                eor #$ff             ; 0=ignore
                and _i*256,y         ; get the non-ignore bits
                ora system_via.t1l_l ; apply pattern bytes
                cmp patterns,x
                beq +
                
                ldx #_i
                txs             ; S = page
                jmp error
+
                .endfor

                inx
                cpx #size(patterns)
                bne fill_loop
                jmp test

error:
                ; S = page
                ; Y = page offset
                ; A = got byte
                ; patterns,x = wanted byte

                eor patterns,x
                sta system_via.t1l_l ; incorrect bits

                sty system_via.t1l_h ; page offset
                
                .set_mode crtc_teletext,-1,$4a

                ldx #8+6
                stx system_via.orb
                ldx #8+7
                stx system_via.orb

                ldx #0
                lda #EMPTY_CHAR
cls_loop:
                sta $7c00,x
                sta $7d00,x
                sta $7e00,x
                sta $7f00,x
                inx
                bne cls_loop

                ; Problem address
                tsx
                txa
                .draw_msn_glyph mode_7_addr(0,0)
                tsx
                txa
                .draw_msn_glyph mode_7_addr(8,0)
                lda system_via.t1l_h
                .draw_msn_glyph mode_7_addr(16,0)
                lda system_via.t1l_h
                .draw_lsn_glyph mode_7_addr(24,0)

                ; Problem bits
                lda system_via.t1l_l
                .draw_msn_glyph mode_7_addr(0,8)
                lda system_via.t1l_l
                .draw_lsn_glyph mode_7_addr(8,8)

                .cerror *!=hang ; must fall through
                .endproc
                
hang:
                jmp hang

;-------------------------------------------------------------------------

msn_digit:
                .for _i=0,_i<256,_i+=1
                .byte format("%X",_i>>4)
                .endfor

lsn_digit:
                .for _i=0,_i<16,_i+=1
                .byte format("%X",_i&15)
                .endfor

;-------------------------------------------------------------------------

xdigit_keys:
                .byte key_0
                .byte key_1
                .byte key_2
                .byte key_3
                .byte key_4
                .byte key_5
                .byte key_6
                .byte key_7
                .byte key_8
                .byte key_9
                .byte key_a
                .byte key_b
                .byte key_c
                .byte key_d
                .byte key_e
                .byte key_f

;-------------------------------------------------------------------------

patterns_reset: .segment reset
                .if \reset!=0
                .byte $00
                .byte $ff
                .endif
                .endsegment

patterns: .block
                .for _reset:=0,_reset<2,_reset+=1
                .byte $00
                .for _i=0,_i<8,_i+=1
                .byte (1<<_i)
                .patterns_reset _reset
                .endfor
                .byte $aa
                .patterns_reset _reset
                .byte $55
                .patterns_reset _reset
                .for _i:=0,_i<8,_i+=1
                .byte (~(1<<_i))&$ff
                .patterns_reset _reset
                .endfor
                .for _i:=0,_i<8,_i+=1
                .byte ($ff<<_i)&$ff
                .patterns_reset _reset
                .endfor
                .for _i:=0,_i<8,_i+=1
                .byte $ff>>_i
                .patterns_reset _reset
                .endfor
                .endfor
                .endblock

;-------------------------------------------------------------------------

crtc_teletext: .block
                .byte  $3F  ; 0 Horizontal Total     =64
                .byte  $28  ; 1 Horizontal Displayed =40
                .byte  $33  ; 2 Horizontal Sync      =&33  Note: &31 is a better value
                .byte  $24  ; 3 HSync Width+VSync    =&24  VSync=2, HSync=4
                .byte  $1E  ; 4 Vertical Total       =30
                .byte  $02  ; 5 Vertical Adjust      =2
                .byte  $19  ; 6 Vertical Displayed   =25
                .byte  $1B  ; 7 VSync Position       =&1B
                .byte  $93  ; 8 Interlace+Cursor     =&93  Cursor=2, Display=1, Interlace=Sync+Video
                .byte  $12  ; 9 Scan Lines/Character =19
                .byte  $72 ;10 Cursor Start Line    =&72  Blink=On, Speed=1/32, Line=18
                .byte  $13  ;11 Cursor End Line      =19
                .byte $28,$00   ;12,13 start address
                .byte $28,$00   ; 14,15 cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_20KB: .block  ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
                .byte 0,0             ;R12,R13 - start address
                .byte $10,0;$30>>3,0             ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_10KB: .block ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total
                .byte $00                 ;R5 - Vertical Total Adjust
                .byte $20                 ;R6 - Vertical Displayed
                .byte $22                 ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
                .byte 0,0               ; R12,R13 - start address
                .byte $10,0               ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

palette_mono:
                .for _i=0,_i<16,_i+=1
                .byte _i<<4|(_i<8?7:0)
                .endfor

;-------------------------------------------------------------------------

engtest:
                .binary "engtest.dat"

;-------------------------------------------------------------------------

                .include "build/glyphs_data.generated.s65"
                
;-------------------------------------------------------------------------

nmi_entry_point:
                rti

;-------------------------------------------------------------------------

irq_entry_point:
                rti
                .endsection

;-------------------------------------------------------------------------

                .section vectors
                .word nmi_entry_point
                .word reset_entry_point
                .word irq_entry_point
                .endsection

;-------------------------------------------------------------------------
