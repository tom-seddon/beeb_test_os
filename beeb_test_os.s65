
                .include "submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

; Better to use $20 than $00, as if bits other than bit 5 are stuck
; high then you won't get any control chars that could muck things up.
;
; If bit 5 is stuck low, best hope other bits aren't stuck high!
EMPTY_CHAR=$20
FILL_CHAR=$ff

;-------------------------------------------------------------------------

                .weak
model_b=false
model_bplus=false
model_master=false
                .endweak

                .if (model_b?1:0)+(model_bplus?1:0)+(model_master?1:0)!=1
                .error "must specify single model type"
                .endif

;-------------------------------------------------------------------------

*=$c000

                .if model_b||model_bplus

                ; For B+, memory test needs to go first, as the shadow
                ; RAM loads/stores need to be in the MOS VDU driver
                ; area at $c000-$dfff.
                .dsection memory_test
                .dsection user_interface
                .dsection bits_test
                .dsection data
                .dsection memory_test_patterns

                .elif model_master

                .dsection user_interface
                .dsection bits_test
                .dsection data

                ; For Master, memory test wants to go last, as it has
                ; to be out of the way of HAZEL.
                .if *<$e000
*=$e000
                .endif
                .dsection memory_test
                .dsection memory_test_patterns
                
                .endif
                
                .dsection entry_points
                
                .cerror *>$fffa,'code overflow'
*=$fffa
                .dsection vectors

;-------------------------------------------------------------------------

; Preserves Y/C
set_mode: .macro table,palette,ula
                lda #\ula
                sta video_ula_control

                ldx #size(\table)-1
-
                stx $fe00
                lda \table,x
                sta $fe01
                dex
                bpl -

                .if \palette>=0
                ldx #15
-
                lda \palette,x
                sta video_ula_palette
                dex
                bpl -
                .endif
                .endmacro

; Preserves Y/C
copy_message: .macro addr,text
                ldx #0
-
                inx
                lda \text-1,x
                sta \addr-1,x
                bpl -
                .endmacro

; Preserves A/Y/C
handle_key: .macro key,routine
                ldx #\key
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl not_pressed
wait_for_up_loop:
                bit system_via.ora_no_handshake
                bmi wait_for_up_loop
                jmp \routine
not_pressed:
                .endmacro

; Preserves A/Y
cycle_crtc_address: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                cmp #$20
                bcs cycle_done  ; taken if mode 7 - don't adjust
                clc
                adc #$20>>3     ; +8 KB
                cmp #$10        ; past end of RAM?
                bcc got_addr    ; taken if ok
                lda #$00        ; reset address
got_addr:
                sta $fe01       ; update address
cycle_done:
                txa
                .endmacro

; Preserves A/Y
show_crtc_address_in_LEDs: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                and #%00001100  ; extract 8 KB region index
                
                ; Reflect address in LEDs. Only bits 0-3 of ORB are
                ; outputs so bits 4-7 in the value written can be
                ; anything.
                asl a           ; %000xy000
                eor #%00011000  ; since 1=LED off, 0=LED on
                ora #7          ; do shift lock LED
                sta system_via.orb
                lsr a
                and #8          ; mask off just LED state
                ora #6          ; do caps lock LED
                sta system_via.orb
                .endmacro

draw_msn_glyph: .macro addr
                and #$f0        ; (n>>4)*16
                lsr a           ; (n>>4)*8
                .draw_glyph \addr
                .endmacro

draw_lsn_glyph: .macro addr
                and #$0f
                asl a
                asl a
                asl a
                .draw_glyph \addr
                .endmacro

draw_glyph: .macro addr
                tax
                ldy #7
loop:
                .for _y=0,_y<8,_y+=1
                lda glyphs_rows[_y],x
                sta \addr+_y*40,y
                .endfor
                inx
                dey
                bpl loop
                .endmacro

mode_7_addr: .function _x,_y
                .endfunction $7c00+_y*40+_x

; Preserves X/Y/C
activate_shadow: .macro
                .if model_bplus
                lda #$80
                sta acccon
                .elif model_master
                lda #acccon.x
                tsb acccon
                .else
                .cerror
                .endif
                .endmacro

deactivate_shadow: .macro
                .if model_bplus
; Preserves X/Y/C
                lda #$00
                sta acccon
                .elif model_master
                lda #acccon.x
                trb acccon
                .else
                .cerror
                .endif
                .endmacro
                
;-------------------------------------------------------------------------

                .section user_interface
reset:

                ; disable ANDY on B+
                lda #0
                sta $fe30       ; disable ANDY (if B+ or later)

                ; disable shadow RAM on B+
                sta $fe34       ; select main RAM (if B+ or later)
                
                ; check if initialisation was (probably) run on a
                ; previous boot
                ldy #0          ; not previously initialised
                lda system_via.ddra
                cmp #%01111111
                bne +
                lda system_via.ddrb
                cmp #%00001111
                bne +
                lda system_via.acr
                bne +

                ; Looks like this isn't a power-on boot
                dey
+
                ; Port B writes to addressable latch
                lda #%00001111
                sta system_via.ddrb

                ; Disable port A input latching
                lda #0
                sta system_via.acr

                ; Disable sound write, speech read, speech write,
                ; keyboard write.
                ldx #8+0
                stx system_via.orb ; bit 0 - sound write
                inx
                stx system_via.orb ; bit 1 - speech read
                inx
                stx system_via.orb ; bit 2 - speech write
                inx
                stx system_via.orb ; bit 3 - keyboard write

                ; Silence sound
                lda #%10011111  ; tone 3 max attenuation
silence_sound_loop:
                ldx #$ff
                stx system_via.ddra
                sta system_via.ora_no_handshake
                ldx #0+0
                stx system_via.orb
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                nop
                ldx #8+0
                stx system_via.orb
                clc
                adc #%00100000  ; next channel
                bcc silence_sound_loop

                ; Port A keyboard access
                lda #%01111111
                sta system_via.ddra

                lda #8+0        ; disable sound write
                sta system_via.orb
                lda #8+1        ; disable speech read
                sta system_via.orb
                lda #8+2        ; disable speech write
                sta system_via.orb
                lda #0+3        ; enable keyboard write
                sta system_via.orb

                ; set 20 KB CRTC wraparound
                lda #8+5
                sta system_via.orb
                lda #0+4
                sta system_via.orb
                
                lda #0+6        ; caps lock LED off
                sta system_via.orb
                lda #8+7        ; shift lock LED off
                sta system_via.orb

                lda #0
                .rept 10
                sta 0
                .endrept

                ; Only initialise mode on a power-on reset
                cpy #0
                bne +
                .set_mode crtc_teletext,-1,$4a
+
                
main_menu:
                ldy #0          ; LED state counter
main_menu_loop:
                ; .handle_key key_caps_lock,toggle_caps_lock_led
                .handle_key key_m,memory_test
                .handle_key key_b,bits_test
                .handle_key key_0,set_mode_0
                .handle_key key_4,set_mode_4
                .handle_key key_7,set_mode_7
                .handle_key key_e,teletext_engineering_test
                .handle_key key_x,memory_test.error

                ; delay ~3,000 cycles
                ldx #0
delay_loop:
                .rept 10
                nop
                .endrept
                inx
                bne delay_loop

                iny
                tya
                lsr a           ; 07654321
                lsr a           ; 00765432
                lsr a           ; 00076543
                lsr a           ; 00007654
                and #8
                ora #6          ; caps lock LED
                sta system_via.orb
                eor #8|(6^7)    ; opposite state for shift lock LED
                sta system_via.orb
                
                jmp main_menu_loop

set_mode_0:
                .set_mode crtc_20KB,palette_mono,$9c
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

set_mode_4:
                .set_mode crtc_10KB,palette_mono,$88
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

teletext_engineering_test:
                ldx #0
-
                .for _i=0,_i<4,_i+=1
                lda engtest+_i*256,x
                sta $7c00+_i*256,x
                .endfor
                inx
                bne -
                
                .cerror *!=set_mode_7 ; fall through

set_mode_7:
                .set_mode crtc_teletext,-1,$4a
                jmp main_menu_loop
                .endsection

;-------------------------------------------------------------------------

                .section bits_test
bits_test: .proc

fill_00:
                lda #$00
fill:
                ldx #0
fill_loop:
                .for _i=0,_i<128,_i+=1
                sta _i*256,x
                .endfor
                inx
                bne fill_loop

test_loop:
                handle_key key_space,toggle_address
                handle_key key_0,toggle_0
                handle_key key_1,toggle_1
                handle_key key_2,toggle_2
                handle_key key_3,toggle_3
                handle_key key_4,toggle_4
                handle_key key_5,toggle_5
                handle_key key_6,toggle_6
                handle_key key_7,toggle_7
                handle_key key_8,fill_00
                handle_key key_9,fill_ff
                handle_key key_f,fill
                jmp test_loop

fill_ff:
                lda #$ff
                jmp fill

toggle_0:
                eor #$01
                jmp fill

toggle_1:
                eor #$02
                jmp fill

toggle_2:
                eor #$04
                jmp fill

toggle_3:
                eor #$08
                jmp fill

toggle_4:
                eor #$10
                jmp fill

toggle_5:
                eor #$20
                jmp fill

toggle_6:
                eor #$40
                jmp fill

toggle_7:
                eor #$80
                jmp fill

toggle_address:
                .cycle_crtc_address
                .show_crtc_address_in_LEDs
                jmp test_loop
               .endproc
               .endsection
                
;-------------------------------------------------------------------------

; Page numbers:

; Range       B         B+          Master
; -----       -         --          ------
; $00 - $7F   Main RAM
; $80 - $90   -         ANDY        ANDY
; $A0 - $AF   -         ANDY        HAZEL
; $B0 - $FF   -         Shadow RAM  Shadow RAM
                
test_page_address: .function page
                .if page>=0&&page<$80
                ; main RAM
_addr=page*256
                .elsif model_bplus&&page>=$80&&page<$b0
_addr=page*256
                .elsif (model_bplus||model_master)&&page>=$b0&&page<$100
                .if model_bplus
                ; access to this region is only possible from
                ; instructions fetched from a particular address
                ; range.
                .cerror !(*>=$c000&&*<$e000)
                .endif
_addr=(page-($b0-$30))*256
                .elsif model_master&&page>=$80&&page<$90
_addr=page*256
                .elsif model_master&&page>=$90&&page<$b0
                ; code accessing this region should be placed elsewhere!
                .cerror *>=$c000&&*<$e000
_addr=$c000+(page-$90)*256
                .else
                .error format("invalid page number: $%02x (%d)",page,page)
                .endif
                .endfunction _addr
                
test_fill_iteration: .segment page
                sta test_page_address(\page),y
                .endsegment

                .section memory_test
test_check_iteration: .segment page
                lda test_page_address(\page),y ; fetch memory byte
                eor patterns,x                 ; get differences from pattern
                and system_via.t1l_h           ; mask out ignore bits
                beq +
                
                ldx #\page
                jmp error
+
                .endsegment
                
memory_test: .proc
                ; the T1 latch can act as a handy 16 bits of (slightly
                ; slow) RAM. IRQs are disabled so it doesn't matter if
                ; the timer times out more often.
                lda #$ff
                sta system_via.t1l_h ; keep bits
                
                ldx #key_shift
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl test

read_msn:
                ldx #8+6        ; caps lock off
                stx system_via.orb
                ldx #8+7        ; shift lock off
                stx system_via.orb

                ldx #15
msn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_msn_key
wait_for_msn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_msn_key_up
                txa
                asl a
                asl a
                asl a
                asl a
                sta system_via.t1l_h
                jmp read_lsn
next_msn_key:
                dex
                bpl msn_loop
                jmp read_msn

read_lsn:
                ldx #0+6        ; caps lock on
                stx system_via.orb

                ldx #15
lsn_loop:
                lda xdigit_keys,x
                sta system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl next_lsn_key
wait_for_lsn_key_up:
                bit system_via.ora_no_handshake
                bmi wait_for_lsn_key_up
                txa
                ora system_via.t1l_h
                eor #$ff        ; convert ignore bits to keep bits
                sta system_via.t1l_h
                jmp test
next_lsn_key:
                dex
                bpl lsn_loop
                jmp read_lsn
                
test:
                ; There's no keyboard input from this point, so the
                ; system VIA ACR is available for use.

                ldx #0          ; per-byte increment
                stx system_via.acr

                ; 
                
                ldx #0+6        ; caps lock on
                stx system_via.orb
                ldx #0+7        ; shift lock on
                stx system_via.orb

                .if model_bplus||model_master
                ; enable ANDY
                lda #$80
                sta romsel
                .endif

                .if model_master
                ; page in HAZEL
                .cerror *>=$c000&&*<$e000
                lda #acccon.y
                tsb acccon
                .endif

test_loop:
                
                ldx #0
                txs             ; loop cunter
                
                ldy #0          ; Y = page offset
fill_loop:
                lda patterns,x

                ; fill main RAM                
                .for _i=0,_i<$80,_i+=1
                .test_fill_iteration _i
                .endfor

                .if model_bplus||model_master
                
                ; fill ANDY
                .for _i=$80,_i<$b0,_i+=1
                .test_fill_iteration _i
                .endfor

                ; fill shadow
                .activate_shadow
                lda patterns,x
                .for _i=$c0,_i<$100,_i+=1
                .test_fill_iteration _i
                .endfor
                .deactivate_shadow

                .endif

                clc
                txa
                adc system_via.acr
                and #size(patterns)-1
                tax
                
                iny
                bne fill_loop

                tsx
check_loop:
                .for _i=0,_i<$80,_i+=1
                .test_check_iteration _i
                .endfor

                .if model_bplus||model_master

                ; check ANDY
                .for _i=$80,_i<$b0,_i+=1
                .test_check_iteration _i
                .endfor

                ; check shadow
                .activate_shadow
                .for _i=$c0,_i<$100,_i+=1
                .test_check_iteration _i
                .endfor
                .deactivate_shadow

                .endif

                clc
                txa
                adc system_via.acr
                and #size(patterns)-1
                tax

                iny
                bne check_loop

                pla             ; inc S
                tsx
                cpx #size(patterns)
                bne fill_loop

                inc system_via.acr
                
                jmp test_loop

error:
                ; X = page
                ; Y = page offset
                ; A = incorrect bits

                txs                  ; save page
                sta system_via.t1l_l ; incorrect bits
                sty system_via.t1l_h ; page offset

                .if model_bplus||model_master
                .deactivate_shadow
                .endif

                .if model_master
                lda #acccon.y
                trb acccon
                .endif
                
                .set_mode crtc_teletext,-1,$4a

                ldx #8+6
                stx system_via.orb
                ldx #8+7
                stx system_via.orb

                ldx #0
                lda #EMPTY_CHAR
cls_loop:
                sta $7c00,x
                sta $7d00,x
                sta $7e00,x
                sta $7f00,x
                inx
                bne cls_loop

                ; Problem address
                tsx
                txa
                .draw_msn_glyph mode_7_addr(0,0)
                tsx
                txa
                .draw_msn_glyph mode_7_addr(8,0)
                lda system_via.t1l_h
                .draw_msn_glyph mode_7_addr(16,0)
                lda system_via.t1l_h
                .draw_lsn_glyph mode_7_addr(24,0)

                ; Problem bits
                lda system_via.t1l_l
                .draw_msn_glyph mode_7_addr(0,8)
                lda system_via.t1l_l
                .draw_lsn_glyph mode_7_addr(8,8)

                .cerror *!=hang ; must fall through
                .endproc
                
hang:
                jmp hang

                .endsection

;-------------------------------------------------------------------------

                .section memory_test_patterns
pattern: .segment value
                .byte (\value)&$ff
                .byte (\value)&$ff^$ff
                .endsegment

patterns: .block
                ; .byte 1,2,4,8,16,32,64,128
                
                .pattern %00000000
                .pattern %01010101
                .pattern %00110011
                
                ; 5 bytes from random.org
                .pattern $a2
                .pattern $37
                .pattern $38
                .pattern $a5
                .pattern $57 
                
                .for _i=0,_i<8,_i+=1
                .pattern (1<<_i)
                .endfor
                .for _i=0,_i<8,_i+=1
                .pattern ($ff<<_i)
                .endfor
                .for _i=0,_i<8,_i+=1
                .pattern ($ff>>_i)
                .endfor
                
                .cerror ((*-patterns)&(*-patterns-1))!=0,format('not power of 2: %d',*-patterns)
                .endblock
                .endsection
                
;-------------------------------------------------------------------------

                .section data
msn_digit:
                .for _i=0,_i<256,_i+=1
                .byte format("%X",_i>>4)
                .endfor

lsn_digit:
                .for _i=0,_i<16,_i+=1
                .byte format("%X",_i&15)
                .endfor

;-------------------------------------------------------------------------

xdigit_keys:
                .byte key_0
                .byte key_1
                .byte key_2
                .byte key_3
                .byte key_4
                .byte key_5
                .byte key_6
                .byte key_7
                .byte key_8
                .byte key_9
                .byte key_a
                .byte key_b
                .byte key_c
                .byte key_d
                .byte key_e
                .byte key_f

;-------------------------------------------------------------------------

crtc_teletext: .block
                .byte  $3F  ; 0 Horizontal Total     =64
                .byte  $28  ; 1 Horizontal Displayed =40
                .byte  $33  ; 2 Horizontal Sync      =&33  Note: &31 is a better value
                .byte  $24  ; 3 HSync Width+VSync    =&24  VSync=2, HSync=4
                .byte  $1E  ; 4 Vertical Total       =30
                .byte  $02  ; 5 Vertical Adjust      =2
                .byte  $19  ; 6 Vertical Displayed   =25
                .byte  $1B  ; 7 VSync Position       =&1B
                .byte  $93  ; 8 Interlace+Cursor     =&93  Cursor=2, Display=1, Interlace=Sync+Video
                .byte  $12  ; 9 Scan Lines/Character =19
                .byte  $72 ;10 Cursor Start Line    =&72  Blink=On, Speed=1/32, Line=18
                .byte  $13  ;11 Cursor End Line      =19
                .byte $28,$00   ;12,13 start address
                .byte $28,$00   ; 14,15 cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_20KB: .block  ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
                .byte 0,0             ;R12,R13 - start address
                .byte $10,0;$30>>3,0             ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_10KB: .block ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total
                .byte $00                 ;R5 - Vertical Total Adjust
                .byte $20                 ;R6 - Vertical Displayed
                .byte $22                 ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
                .byte 0,0               ; R12,R13 - start address
                .byte $10,0               ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

palette_mono:
                .for _i=0,_i<16,_i+=1
                .byte _i<<4|(_i<8?7:0)
                .endfor

;-------------------------------------------------------------------------

engtest:
                .binary "engtest.dat"

;-------------------------------------------------------------------------

                .include "build/glyphs_data.generated.s65"

                .endsection
                
;-------------------------------------------------------------------------

                .section entry_points

reset_entry_point:
                sei
                lda #0
                .rept 5
                sta 0
                .endrept

                .if model_master
                ; Can't really avoid resetting this completely, as if
                ; TST is set then the value read is junk.
                stz acccon
                .endif
                
                jmp reset

;-------------------------------------------------------------------------

nmi_entry_point:
                rti

;-------------------------------------------------------------------------

irq_entry_point:
                rti
                .endsection

;-------------------------------------------------------------------------

                .section vectors
                .word nmi_entry_point
                .word reset_entry_point
                .word irq_entry_point
                .endsection

;-------------------------------------------------------------------------
