                .include "submodules/beeb/include/beeb.s65"

;-------------------------------------------------------------------------

*=0
                .dsection zp
                
*=$c000
                ; don't put anything in the VDU driver region.
                brk
*=$e000
                .dsection code
                .cerror *>$fffa,'code overflow'
*=$fffa
                .dsection vectors

;-------------------------------------------------------------------------

; value OR'd into all test patterns when read - use to exclude bits
; known to be bad
test_mask=0

;-------------------------------------------------------------------------

; Preserves Y/C
set_mode: .macro table,palette,ula
                lda #\ula
                sta video_ula_control

                ldx #size(\table)-1
-
                stx $fe00
                lda \table,x
                sta $fe01
                dex
                bpl -

                .if \palette>=0
                ldx #15
-
                lda \palette,x
                sta video_ula_palette
                dex
                bpl -
                .endif
                .endmacro

; Preserves Y/C
copy_message: .macro addr,text
                ldx #0
-
                inx
                lda \text-1,x
                sta \addr-1,x
                bpl -
                .endmacro

; Preserves A/Y/C
handle_key: .macro key,routine
                ldx #\key
                stx system_via.ora_no_handshake
                bit system_via.ora_no_handshake
                bpl not_pressed
wait_for_up_loop:
                bit system_via.ora_no_handshake
                bmi wait_for_up_loop
                jmp \routine
not_pressed:
                .endmacro

; Preserves A/Y
cycle_crtc_address: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                cmp #$20
                bcs cycle_done  ; taken if mode 7 - don't adjust
                clc
                adc #$20>>3     ; +8 KB
                cmp #$10        ; past end of RAM?
                bcc got_addr    ; taken if ok
                lda #$00        ; reset address
got_addr:
                sta $fe01       ; update address
cycle_done:
                txa
                .endmacro

; Preserves A/Y
show_crtc_address_in_LEDs: .macro
                tax
                lda #12
                sta $fe00
                lda $fe01
                and #%00001100  ; extract 8 KB region index
                
                ; Reflect address in LEDs. Only bits 0-3 of ORB are
                ; outputs so bits 4-7 in the value written can be
                ; anything.
                asl a           ; %000xy000
                eor #%00011000  ; since 1=LED off, 0=LED on
                ora #7          ; do shift lock LED
                sta system_via.orb
                lsr a
                and #8          ; mask off just LED state
                ora #6          ; do caps lock LED
                sta system_via.orb
                .endmacro
                
;-------------------------------------------------------------------------

                .section zp

                ; These values are not guaranteed to be correct, of
                ; course, if the memory is borked! But what else can
                ; you do?
wanted_byte: .fill 0
got_byte: .fill 0
                .endsection
                
;-------------------------------------------------------------------------


                .section code
nmi_entry_point:
                rti

irq_entry_point:
                rti

reset_entry_point:
                sei

                lda #0
                .rept 5
                sta 0
                .endrept

                lda #0
                sta $fe30       ; disable ANDY (if B+ or later)
                sta $fe34       ; select main RAM (if B+ or later)

                ; check if initialisation was (probably) run on a
                ; previous boot
                ldx #0          ; not previously initialised
                lda system_via.ddra
                cmp #%01111111
                bne +
                lda system_via.ddrb
                cmp #%00001111
                bne +
                lda system_via.acr
                bne +

                ; Looks like this isn't a power-on boot
                dex
+

                ; Port A keyboard access
                lda #%01111111
                sta system_via.ddra

                ; Port B writes to addressable latch
                lda #%00001111
                sta system_via.ddrb

                ; Disable port A input latching
                lda #0
                sta system_via.acr

                lda #8+0        ; disable sound write
                sta system_via.orb
                lda #8+1        ; disable speech read
                sta system_via.orb
                lda #8+2        ; disable speech write
                sta system_via.orb
                lda #0+3        ; enable keyboard write
                sta system_via.orb

                ; set 20 KB CRTC wraparound
                lda #8+5
                sta system_via.orb
                lda #0+4
                sta system_via.orb
                
                lda #0+6        ; caps lock LED off
                sta system_via.orb
                lda #8+7        ; shift lock LED off
                sta system_via.orb

                lda #0
                .rept 10
                sta 0
                .endrept

                ; Only initialise mode on a power-on reset
                cpx #0
                bne +
                .set_mode crtc_teletext,-1,$4a
+
                
main_menu:
                ldy #0          ; LED state counter
main_menu_loop:
                ; .handle_key key_caps_lock,toggle_caps_lock_led
                .handle_key key_m,memory_test
                .handle_key key_c,clear_test
                .handle_key key_p,patterns_test
                .handle_key key_b,bits_test
                .handle_key key_0,set_mode_0
                .handle_key key_4,set_mode_4
                .handle_key key_7,set_mode_7
                

                ; delay ~3,000 cycles
                ldx #0
delay_loop:
                .rept 10
                nop
                .endrept
                inx
                bne delay_loop

                iny
                tya
                lsr a           ; 07654321
                lsr a           ; 00765432
                lsr a           ; 00076543
                lsr a           ; 00007654
                and #8
                ora #6          ; caps lock LED
                sta system_via.orb
                eor #8|(6^7)    ; opposite state for shift lock LED
                sta system_via.orb
                
                jmp main_menu_loop

set_mode_0:
                .set_mode crtc_20KB,palette_mono,$9c
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

set_mode_4:
                .set_mode crtc_10KB,palette_mono,$88
                .show_crtc_address_in_LEDs
                jmp main_menu_loop

set_mode_7:
                .set_mode crtc_teletext,-1,$4a
                jmp main_menu_loop

;-------------------------------------------------------------------------

bits_test: .proc

fill_00:
                lda #$00
fill:
                ldx #0
fill_loop:
                .for _i=0,_i<128,_i+=1
                sta _i*256,x
                .endfor
                inx
                bne fill_loop

test_loop:
                handle_key key_space,toggle_address
                handle_key key_0,toggle_0
                handle_key key_1,toggle_1
                handle_key key_2,toggle_2
                handle_key key_3,toggle_3
                handle_key key_4,toggle_4
                handle_key key_5,toggle_5
                handle_key key_6,toggle_6
                handle_key key_7,toggle_7
                handle_key key_8,fill_00
                handle_key key_9,fill_ff
                handle_key key_f,fill
                jmp test_loop

fill_ff:
                lda #$ff
                jmp fill

toggle_0:
                eor #$01
                jmp fill

toggle_1:
                eor #$02
                jmp fill

toggle_2:
                eor #$04
                jmp fill

toggle_3:
                eor #$08
                jmp fill

toggle_4:
                eor #$10
                jmp fill

toggle_5:
                eor #$20
                jmp fill

toggle_6:
                eor #$40
                jmp fill

toggle_7:
                eor #$80
                jmp fill


toggle_address:
                .cycle_crtc_address
                .show_crtc_address_in_LEDs
                jmp test_loop
               .endproc
               
                
;-------------------------------------------------------------------------

patterns_test: .proc
                lda #1
pattern_fill:
                ldx #0
pattern_fill_loop:
                .for _i=0,_i<128,_i+=1
                sta _i*256,x
                .endfor
                cmp #$80
                rol a
                inx
                bne pattern_fill_loop

patterns_test_loop:
                handle_key key_space,change_address
                handle_key key_p,rotate_pattern
                handle_key key_f,pattern_fill
                jmp patterns_test_loop

rotate_pattern:
                cmp #$80
                rol a
                jmp pattern_fill

change_address:
                .cycle_crtc_address
                .show_crtc_address_in_LEDs
                jmp patterns_test_loop
                .endproc
                
;-------------------------------------------------------------------------

clear_test:
                lda #0
                sta $fe34       ; shadow ram off
                ; lda #$80
                ; sta $fe30       ; ANDY on
                ; lda #0
                ldx #0
clear_fill_loop:
                ; ; clear shadow RAM
                ; ldy #$80
                ; sty $fe34
                ; .for _i=$30,_i<$80,_i+=1
                ; sta _i*256,x
                ; .endfor
                ; clear main RAM
                ; ldy #0
                ; sty $fe34
                .for _i=0,_i<128,_i+=1
                sta _i*256,x
                .endfor
                ; ; clear ANDY
                ; .for _i=$80,_i<$b0,_i+=1
                ; sta _i*256,x
                ; .endfor
                
                inx
                bne clear_fill_loop

clear_read_loop:
                ; constantly read main RAM
                .for _i=0,_i<128,_i+=1
                lda _i*256,x
                .endfor
                inx
                jmp clear_read_loop
                
;-------------------------------------------------------------------------

memory_test: .proc
test:
                ldx #0          ; X = pattern index
                ldy #0          ; Y = page offset
fill_loop:
                lda patterns,x

                .for _i=0,_i<128,_i+=1
                sta _i*256,y
                .endfor

                iny
                bne fill_loop

check_loop:
                .for _i=0,_i<128,_i+=1
                lda _i*256,y
                .if test_mask!=0
                ora #test_mask
                .endif
                cmp patterns,x
                beq +

                sta got_byte
                lda patterns,x
                sta wanted_byte
                
                ldx #_i
                txs             ; S = page
                jmp error
+
                .endfor

                inx
                cpx #size(patterns)
                bne fill_loop
                jmp test

error:
                ; S = page
                ; Y = page offset

                .set_mode crtc_teletext,-1,$4a

                ldx #0
cls_loop:
                sta $7c00,x
                sta $7d00,x
                sta $7e00,x
                sta $7f00,x
                inx
                bne cls_loop

                .copy_message memory_test_messages.address_addr,memory_test_messages.address_message
                lda msn_digit,y
                sta memory_test_messages.address_addr+2,x
                lda lsn_digit,y
                sta memory_test_messages.address_addr+3,x

                txa
                tay
                tsx
                lda msn_digit,x
                sta memory_test_messages.address_addr+0,y
                lda lsn_digit,x
                sta memory_test_messages.address_addr+1,y

                .copy_message memory_test_messages.wanted_addr,memory_test_messages.wanted_message
                ldy wanted_byte
                lda msn_digit,y
                sta memory_test_messages.wanted_addr+0,x
                lda lsn_digit,y
                sta memory_test_messages.wanted_addr+1,x

                .copy_message memory_test_messages.got_addr,memory_test_messages.got_message
                ldy got_byte
                lda msn_digit,y
                sta memory_test_messages.got_addr+0,x
                lda lsn_digit,y
                sta memory_test_messages.got_addr+1,x
                .cerror *!=hang ; must fall through
                .endproc
                
hang:
                jmp hang

;-------------------------------------------------------------------------

memory_test_messages: .block
                
address_addr=$7c00+40
address_message:
                .shift "Address: &"

wanted_addr=$7c00+2*40
wanted_message:
                .shift "Wanted:  &"

got_addr=$7c00+3*40
got_message:
                .shift "Got:     &"
                .endblock

;-------------------------------------------------------------------------

msn_digit:
                .for _i=0,_i<256,_i+=1
                .byte format("%X",_i>>4)
                .endfor

lsn_digit:
                .for _i=0,_i<256,_i+=1
                .byte format("%X",_i&15)
                .endfor

;-------------------------------------------------------------------------

patterns: .block
                .byte $00|test_mask
                .for _i=0,_i<8,_i+=1
                .byte (1<<_i)|test_mask
                .byte $00|test_mask
                .byte $ff|test_mask
                .endfor
                .byte $aa|test_mask
                .byte $00|test_mask
                .byte $55|test_mask
                .byte $00|test_mask
                .for _i:=0,_i<8,_i+=1
                .byte (~(1<<_i))&$ff|test_mask
                .byte $00|test_mask
                .byte $ff|test_mask
                .endfor
                .endblock

;-------------------------------------------------------------------------

crtc_teletext: .block
                .byte  $3F  ; 0 Horizontal Total     =64
                .byte  $28  ; 1 Horizontal Displayed =40
                .byte  $33  ; 2 Horizontal Sync      =&33  Note: &31 is a better value
                .byte  $24  ; 3 HSync Width+VSync    =&24  VSync=2, HSync=4
                .byte  $1E  ; 4 Vertical Total       =30
                .byte  $02  ; 5 Vertical Adjust      =2
                .byte  $19  ; 6 Vertical Displayed   =25
                .byte  $1B  ; 7 VSync Position       =&1B
                .byte  $93  ; 8 Interlace+Cursor     =&93  Cursor=2, Display=1, Interlace=Sync+Video
                .byte  $12  ; 9 Scan Lines/Character =19
                .byte  $72 ;10 Cursor Start Line    =&72  Blink=On, Speed=1/32, Line=18
                .byte  $13  ;11 Cursor End Line      =19
                .byte $28,$00   ;12,13 start address
                .byte $28,$00   ; 14,15 cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_20KB: .block  ;MODEs 0/1/2
                .byte $7F            ;R0 - Horizontal Total
                .byte $50            ;R1 - Horizontal Displayed
                .byte $62            ;R2 - Horizontal Sync
                .byte $28            ;R3 - Sync Width (%vvvvhhhh)
                .byte $26            ;R4 - Vertical Total
                .byte $00            ;R5 - Vertical Total Adjust
                .byte $20            ;R6 - Vertical Displayed
                .byte $22            ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                    ;R11 - Cursor End
                .byte 0,0             ;R12,R13 - start address
                .byte $10,0;$30>>3,0             ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

crtc_10KB: .block ;MODEs 4/5
                .byte $3f                 ;R0 - Horizontal Total
                .byte $28                 ;R1 - Horizontal Displayed
                .byte $31                 ;R2 - Horizontal Sync
                .byte $24                 ;R3 - Sync Width (%vvvvhhhh)
                .byte $26                 ;R4 - Vertical Total
                .byte $00                 ;R5 - Vertical Total Adjust
                .byte $20                 ;R6 - Vertical Displayed
                .byte $22                 ;R7 - Vertical Sync Position
                .byte 1;CRTC.R8.cursorDelay0|CRTC.R8.displayDelay0|CRTC.R8.interlaceSync ;R8 - Interlace/Delay
                .byte $07               ;R9 - Scan lines per character
                .byte $67;CRTC.R10.blink|CRTC.R10.slowBlink|7 ;R10 - Cursor blink/start
                .byte 8                      ;R11 - Cursor End
                .byte 0,0               ; R12,R13 - start address
                .byte $10,0               ; R14,R15 - cursor position
                .endblock

;-------------------------------------------------------------------------

palette_mono:
                .for _i=0,_i<16,_i+=1
                .byte _i<<4|(_i<8?7:0)
                .endfor
                
;-------------------------------------------------------------------------

                .endsection

;-------------------------------------------------------------------------

                .section vectors
                .word nmi_entry_point
                .word reset_entry_point
                .word irq_entry_point
                .endsection

;-------------------------------------------------------------------------
